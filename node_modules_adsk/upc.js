const axios         = require('axios');
const settings      = require("../upchain-connector/options.js");
const querystring   = require('querystring');
const fs            = require('fs');


let headersUPC = {};


exports.login = function login() {

    return new Promise(function(resolve, reject) {
    
        let params = {
            'grant_type'    : 'password',
            'client_id'     : settings.upcClientId,
            'client_secret' : settings.upcClientSecret,
            'username'      : settings.upcUsername,
            'password'      : settings.upcPassword
        }
        
        axios.post('https://live-sso.upchain.net/auth/realms/upchain/protocol/openid-connect/token', querystring.stringify(params)).then(function (response) {
            
            if(response.status === 200) {
                console.log('    Login to UPC tenant ' + settings.upcTenant + ' successful');
                headersUPC['Authorization']  = "Bearer " + response.data.access_token;
                getCompany(function(companyId) {
                    return resolve(companyId);
                });
            } else {
                console.log('    Login failed');   
                console.log('   ');

                return reject();
            }

        }).catch(function (error) {
            console.log(error);
        });

    });
    
}
function getCompany(callback) {
    
    axios.get('https://live.upchain.net/api/auth/v1/companies', { 'headers' : headersUPC }).then(function (response) {
        
        if(response.data.length > 0)  {

            let companyId = '';
            
            for(company of response.data) {
                if(company.name === settings.upcTenant) {
                    console.log('    Found tenant/company ' + company.name + ' (' + company.id + ')');
                    // axios.defaults.headers.common['Upc-Selected-Company']  = company.id;
                    headersUPC['Upc-Selected-Company']  = company.id;
                    companyId = company.id;
                    continue;
                }
            }

            if(companyId === '') {
                console.log();
                console.log('    ERROR: Could not find tenant/company with name "' + response.data[0].name + '"') ;
                console.log('    Found the following companies instead:');
                for(company of response.data) {
                    console.log('    - ' + company.name);
                }
                console.log();
            } else {
                callback(companyId);
            }
            
        } else {
            console.log('    Coulld not find related companies');   
            console.log('   ');           
        }

    }).catch(function (error) {
        console.log(error);
    });
    
}

// Retrieve internal IDs of workflows and entities
exports.getCustomerId = function getCustomerId(customerName) {

    return new Promise(function(resolve, reject) {

        axios.get('https://live.upchain.net/api/customer/v1/customers', {
            'headers' : headersUPC
        }).then(function (response) {

            let result = '';

            if(customerName === '') {
                if(response.data.length > 0) {
                    result = response.data[0].id;
                }
            } else {
                for(item of response.data) {
                    if(item.customerName === customerName) {
                        result = item.id;
                        break;
                    }
                }
            }

            return resolve(result);

        }).catch(function (error) {
            console.log(error);
        });
        
    });
        
}
exports.getProjectTypeId = function getProjectTypeId(projectType) {
    
    return new Promise(function(resolve, reject) {

        axios.get('https://live.upchain.net/api/project-type/v1/types', {
            'headers' : headersUPC
        }).then(function (response) {

            let result = '';

            for(item of response.data) {
                if(item.name === projectType) {
                    result = item.id;
                    break;
                }
            }

            return resolve(result);

        }).catch(function (error) {
            console.log(error);
        });

    });
    
}
exports.getWorkflowIds = function getWorkflowIds() {
    
    return new Promise(function(resolve, reject) {

        axios.get('https://live.upchain.net/api/workflow/v1/workflows?limit=1000&status=Active', {
            'headers' : headersUPC
        }).then(function (response) {   
            return resolve(response.data.content);
        }).catch(function (error) {
            console.log(error);
        });
    });

}
exports.getWorkflowId = function getWorkflowId(workflowName) {
    
    return new Promise(function(resolve, reject) {

        axios.get('https://live.upchain.net/api/workflow/v1/workflows?limit=1000&status=Active', {
            'headers' : headersUPC
        }).then(function (response) {
                
            let result = '';
    
            for(item of response.data.content) {
                if(item.name === workflowName) {
                    result = item.id;
                    break;
                }
            }
    
            return resolve(result);
    
        }).catch(function (error) {
            console.log(error);
        });
    });

}


// Projects
exports.createProject = function createProject(params) {
    
    return new Promise(function(resolve, reject) {
        axios.post('https://live.upchain.net/api/project/v1/projects', params, {
            'headers' : headersUPC
        }).then(function (response) {
            return resolve(response.data);
        }).catch(function (error) {
            console.log(error);
        });
    });
    
}
exports.getProjectEndItems = function getProjectEndItems(params, callback) {

    return new Promise(function(resolve, reject) {

        let url = 'https://live.upchain.net/api/bom/v2/projects/end-items?id=' + params.projectId + '&filter=' + params.filter;

        axios.get(url, {
            'headers' : headersUPC
        }).then(function (response) {

            let result = response.data[params.projectId];
            if(typeof result === 'undefined') result = [];
            return resolve(result);

        }).catch(function (error) {
            console.log(error);
            return reject();
        });

    });
    
}


// Item
exports.getItemDetails = function getItemDetails(partVersionId) {

    return new Promise(function(resolve, reject) {

        axios.get('https://live.upchain.net/api/bom/v1/part_version/details?ids=' + partVersionId, {
            'headers' : headersUPC
        }).then(function (response) {
            return resolve(response.data[0]);
        }).catch(function (error) {
            console.log(error);
        });
        
    });
        
}
exports.getItemEBOM = function getItemEBOM(partVersionId, projectId, bomRevision, eBomFilter) {

    return new Promise(function(resolve, reject) {

        axios.get('https://live.upchain.net/api/bom/v2/project/' + projectId + '/extended-items/' + partVersionId + '?bomRevision=' + bomRevision + '&eBomFilter=' + eBomFilter, {
            'headers' : headersUPC
        }).then(function (response) {
            return resolve(response.data);
        }).catch(function (error) {
            console.log(error);
        });
        
    });
        
}
exports.getPrimaryFile = function getPrimaryFile(partVersionId) {

    return new Promise(function(resolve, reject) {

        axios.get('https://live.upchain.net/api/bom/v1/part_version/' + partVersionId + '/latest_primary_file_version_object', {
            'headers' : headersUPC
        }).then(function (response) {
            return resolve(response.data.data);
        }).catch(function (error) {
            console.log(error);
        });
        
    });
        
}
exports.getFileTranslations = function getFileTranslations(fileVersionid) {

    return new Promise(function(resolve, reject) {

        axios.get('https://live.upchain.net/api/bom/v1/file_version/' + fileVersionid + '/translations', {
            'headers' : headersUPC
        }).then(function (response) {
            return resolve(response.data);
        }).catch(function (error) {
            console.log(error);
        });
        
    });
        
}
// exports.downloadFile = function downloadFile(fileVersionId, fileName) {
exports.downloadFile =  async (fileVersionId, fileName, folderName) => {

    // console.log(' > downloadFile START');
    // console.log(' > downloadFile fileVersionId : ' + fileVersionId);
    // console.log(headersUPC);
    // console.log(fileVersionId);
    // console.log(folderName);
    // console.log(fileName);
    // console.log('ibefore try');
    
    try {

        // console.log('in try');

        const response = await axios({
            method          : 'GET',
            url             : 'https://live.upchain.net/api/bom/v1/file_version/' + fileVersionId + '/download',
            responseType    : 'stream',
            'headers'       : headersUPC
        });

        // console.log('1');

        // 'https://live.upchain.net/api/bom/v1/file_version/5934710/download',

        let path = fileName;

        // console.log(' > downloadFile path : ' + path);

        if(folderName !== null) {
            if(typeof folderName !== 'undefined') {
                path = folderName + '/' + fileName;
            }
        }

        // console.log(' > downloadFile path : ' + path);

        await response.data.pipe(fs.createWriteStream(path));

        // console.log('download done');

        return;
        
    } catch (err) {
        //throw new Error(err);

        return;
    }

}